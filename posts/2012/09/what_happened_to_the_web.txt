Title: What happened to the Web?
Created: 2012-09-1

Last year, when I set the goal of catching up on web development, I knew that
things had changed since 2005 or so, but I had no idea how much.

At first glance, it seems familiar. There's still the browser / server
separation ([for the most part][1]).  On the server side we still use
databases, although MySQL has lost its place as the de facto standard. We are
still sending HTTP requests over the wire, but we're sending a whole lot more
of them, thanks to Ajax. And on the client side, there's is still dear old
Javascript.

[1]: https://github.com/meteor/meteor

A Brand New Stack
---

"Great, so I'll just fire up the [L][][A][][M][][P][] stack then". Not so
fast.  Linux is still there, thankfully. Apache too, although it's being
squeezed by competition from two sides. For static content there is [nginx][],
an optimized webserver / reverse proxy. For dynamic content, where there
used to be CGI and a few language-specific apache modules, there's now a whole
ecosystem of servers / interfaces. A modern web app deals
with an abstraction layer such as WSGI (Python) or Rack (Ruby). While the
situation is great for the [performance minded][2], the choice may be
overwhelming to someone like me, who just wants to get a weekend project up and running. A simple solution is to defer the choice. Stick to the web
framework's dev server until you figure out what you need.

[L]: http://www.linux.org/
[A]: http://www.apache.org/
[M]: http://www.mysql.com/
[P]: http://www.php.net/
[nginx]: http://nginx.org/
[2]: https://github.com/blog/517-unicorn

Databases
---

SQL is still going strong, but businesses with very high scalability
requirements have been forced to move away from general purpose DBMS towards
key-value stores and document stores (NoSQL). Essentially they are giving up
some of the power of a relational system for better scalability. If you deploy
your app on a cloud service, you may not have a choice of SQL at all. If you
run your app locally like me, it's just a matter of preference.

Frameworks
---

This area has seen significantly more fragmentation than the others. There
used to be a choice of Perl, PHP or the more 'enterprisey' ASP / JSP. You
picked your favorite language and then maybe you added a templating library.
The app was externally visible through a single URL, such as
`/app.php?page=index`. Then Rails came along and changed the expectations of
what a framework was.

A modern framework provides URL routing, which means it binds a function or a
class `posts(id)` to the url `/posts/<id>`. Database access is abstracted
through some sort of object mapping. Templating is baked in.

If any of these components are missing, you are probably dealing with a
*micro-framework* in the modern nomenclature. I'm using Flask, which does
everything except the object mapping.

Meet the browser
---

The server side may be swinging, but the real party is happening in the
browser. When I left the scene, Javascript was a misunderstood gem of a
language. Today it's grown up, and partly due to intense lobbying from Douglas
Crockford and others, is not afraid to rub its noble Scheme heritage in your
face. If things go according to plan, the next Javascript version (Harmony)
will soften some syntactic edges. You don't have to wait though. Web
developers have discovered the wonders of pre-processing, so what used to be
painstakingly hand-written HTML/CSS/JS can now be generated from the
syntactically refined counterparts [HAML][]/[SASS][]/[CoffeeScript][].

[HAML]: http://haml.info/
[SASS]: http://sass-lang.com/
[CoffeeScript]: http://coffeescript.org/

In a weird twist of fate, Javascript has become the machine code of the web.
There's a backend to LLVM [that outputs Javascript][emscripten], which means
just about anything can be made to [compile][jslangs] down to Javascript.
Google's V8 implementation brought performance up to par and set a high
standard, so that running a python interpreter inside a JS interpreter is no
big deal. Debugging may be though, as far as I know, there is no GDB support
for the JS architecture. Chances are someone is working on it right now ...

[emscripten]: https://github.com/kripken/emscripten/wiki
[jslangs]: https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS

Conclusion
---

If I have any regrets, it is that I didn't try to stay up-to-date while the
web was being reinvented. When you are not directly involved, it's easy to
pass off any new development as buzz. There were benefits. I did manage to
save myself from some [buzz][silverlight]. In the end I'm glad to have ended
my hiatus. It's a really exciting time to get back to the web.

[silverlight]: http://www.microsoft.com/silverlight/

